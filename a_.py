# -*- coding: utf-8 -*-
"""A*

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BmqVikJQOxg_zCHJcQmyxCjX-rz86omZ
"""

from collections import deque

class Graph:
    # example of adjacency list (or rather map)
    # adjacency_list = {
    # 'A': [('B', 1), ('C', 3), ('D', 7)],
    # 'B': [('D', 5)],
    # 'C': [('D', 12)]
    # }

    def __init__(self, adjacency_list):
        self.adjacency_list = adjacency_list

    def get_neighbors(self, v):
        return self.adjacency_list[v]

    # heuristic function with equal values for all nodes
    def h(self, n):
        H = {
            'A': 1,
            'B': 1,
            'C': 1,
            'D': 1,
            'E': 1
        }

        return H[n]

    def a_star_algorithm(self, start_node, stop_node):
        # open_list is a list of nodes which have been visited, but who's neighbors
        # haven't all been inspected, starts off with the start node
        # closed_list is a list of nodes which have been visited
        # and who's neighbors have been inspected
        open_list = set([start_node])
        closed_list = set([])

        # g contains current distances from start_node to all other nodes
        # the default value (if it's not found in the map) is +infinity
        g = {}

        g[start_node] = 0

        # parents contains an adjacency map of all nodes
        parents = {}
        parents[start_node] = start_node

        while len(open_list) > 0:
            n = None

            # find a node with the lowest value of f() - evaluation function
            for v in open_list:
                if n == None or g[v] + self.h(v) < g[n] + self.h(n):
                    n = v;

            if n == None:
                print('Path does not exist!')
                return None

            # if the current node is the stop_node
            # then we begin reconstructin the path from it to the start_node
            if n == stop_node:
                reconst_path = []

                while parents[n] != n:
                    reconst_path.append(n)
                    n = parents[n]

                reconst_path.append(start_node)

                reconst_path.reverse()

                print('Path found: {}'.format(reconst_path))
                return reconst_path

            # for all neighbors of the current node do
            for (m, weight) in self.get_neighbors(n):
                # if the current node isn't in both open_list and closed_list
                # add it to open_list and note n as it's parent
                if m not in open_list and m not in closed_list:
                    open_list.add(m)
                    parents[m] = n
                    g[m] = g[n] + weight

                # otherwise, check if it's quicker to first visit n, then m
                # and if it is, update parent data and g data
                # and if the node was in the closed_list, move it to open_list
                else:
                    if g[m] > g[n] + weight:
                        g[m] = g[n] + weight
                        parents[m] = n

                        if m in closed_list:
                            closed_list.remove(m)
                            open_list.add(m)

            # remove n from the open_list, and add it to closed_list
            # because all of his neighbors were inspected
            open_list.remove(n)
            closed_list.add(n)

        print('Path does not exist!')
        return None

adjacency_list = {
    'A': [('B', 1), ('C', 3), ('D', 7)],
    'B': [('D', 5)],
    'C': [('D', 12)],
    'D': [('A', 4),('E', 26), ('C', 5)]
}
graph1 = Graph(adjacency_list)

graph1.a_star_algorithm('C', 'A')

"""GOOGLE MAP"""

import folium
import networkx as nx

# create a grid map
grid_map = [[0, 0, 1, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 0],
            [0, 1, 0, 0]]

# create an adjacency list representation of the grid map
G = nx.Graph()
for row in range(len(grid_map)):
    for col in range(len(grid_map[0])):
        if grid_map[row][col] == 0:
            G.add_node((row, col))
            if row > 0 and grid_map[row-1][col] == 0:
                G.add_edge((row, col), (row-1, col))
            if col > 0 and grid_map[row][col-1] == 0:
                G.add_edge((row, col), (row, col-1))

# define the starting and ending locations
start = (0, 0)
end = (3, 3)

# use the A* algorithm to find the shortest path
path = nx.astar_path(G, start, end)

# print the path
print(path)

map_cp = folium.Map(location=[28.6315, 77.2167])

folium.Marker(location=[28.6292, 77.2291],popup='Modern School, Connaught Place, New Delhi',icon=folium.Icon(color='green', icon='info-sign')).add_to(map_cp)

folium.Marker(location=[28.6172, 77.2082],popup='Parliament, Connaught Place, New Delhi',icon=folium.Icon(color='red', icon='info-sign')).add_to(map_cp)

# use the folium.PolyLine class to add the path to the map
folium.PolyLine(path, color="green", weight=2.5, opacity=1).add_to(map_cp)

map_cp.save("connaught_place.html")

parliament_india_coord = [28.6172, 77.2082]
modern_school_coord = [28.6292, 77.2291]

#create a map centered on Connaught Place, New Delhi using the folium.Map class 
map_cp = folium.Map(location=[28.6315, 77.2167])

# Use the folium.Marker class to add a marker for Parliament of India on the map
folium.Marker(
    location=parliament_india_coord,
    popup='Parliament of India',
    icon=folium.Icon(color='blue', icon='info-sign')
).add_to(map_cp)

# Use the folium.Marker class to add a marker for Modern School on the map
folium.Marker(
    location=modern_school_coord,
    popup='Modern School',
    icon=folium.Icon(color='red', icon='info-sign')
).add_to(map_cp)

# Draw a line between the two markers
folium.PolyLine([parliament_india_coord, modern_school_coord], color="green", weight=2, opacity=1).add_to(map_cp)

# use the save method to save the map as an HTML file
map_cp.save("connaught_place_path.html")

"""## Without roads"""

import math
from geopy.geocoders import Nominatim

geolocator = Nominatim(user_agent="geoapiExercises")

Place_1 = (input("Enter Place One Name : "))
Place_2 = (input("Enter Place Two Name : "))

location_1 = geolocator.geocode(Place_1)
location_2 = geolocator.geocode(Place_2)

long_1 = ("Longitude: ", location_1.longitude)
Lat_1 = ("Latitude: ", location_1.latitude)
long_2 = ("Longitude: ", location_2.longitude)
Lat_2 = ("Latitude: ", location_2.latitude)

coord_1 = [location_1.latitude, location_1.longitude]
coord_2 = [location_2.latitude, location_2.longitude]

# set the starting point and ending point
start_point = coord_1 
end_point = coord_2 

# convert latitudes and longitudes to radians
start_lat, start_lon = math.radians(start_point[0]), math.radians(start_point[1])
end_lat, end_lon = math.radians(end_point[0]), math.radians(end_point[1])

# use the Haversine formula to calculate the distance
a = math.sin((end_lat - start_lat) / 2)**2 + math.cos(start_lat) * math.cos(end_lat) * math.sin((end_lon - start_lon) / 2)**2
c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
distance = 6371 * c  # 6371 is the radius of the Earth

# assuming an average speed of kmph you can calculate the time
time = distance / 10

import folium

# create a map centered at the starting point
m = folium.Map(location=start_point, zoom_start=13)

# add markers for the starting and ending points
folium.Marker(start_point, popup=Place_1).add_to(m)
folium.Marker(end_point, popup=Place_2).add_to(m)

# draw a line between the two points
folium.PolyLine([start_point, end_point], color='red', weight=2.5, opacity=1).add_to(m)

print("Distance: {:.2f} km".format(distance))
print("Time: {:.2f} s".format(time))

m